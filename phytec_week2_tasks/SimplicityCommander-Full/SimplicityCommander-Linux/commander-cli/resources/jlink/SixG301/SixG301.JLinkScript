
/*********************************************************************
*
*       InitTarget
*
*       Setup target AP-layout.
*/
void InitTarget(void) {
  JLINK_CORESIGHT_AddAP(0, CORESIGHT_AHB_AP);
  JLINK_CORESIGHT_AddAP(1, CORESIGHT_CUSTOM_AP);
  JLINK_CORESIGHT_AddAP(2, CORESIGHT_AHB_AP);
  JLINK_CORESIGHT_AddAP(3, CORESIGHT_AHB_AP);
  //
  // Use AP[0] as AHB-AP for target communication
  //
  CORESIGHT_IndexAHBAPToUse = 0;

  // Define Flash aliases.
  JLINK_ExecCommand("map region 0x11000000-0x18FFFFFF A 0x01000000 0x8000000");
  JLINK_ExecCommand("map region 0x61000000-0x68FFFFFF A 0x01000000 0x8000000");
  JLINK_ExecCommand("map region 0x71000000-0x78FFFFFF A 0x01000000 0x8000000");

  // Define RAM aliases.
  JLINK_ExecCommand("map region 0x00800000-0x0087FFFF A 0x20000000 0x80000");
  JLINK_ExecCommand("map region 0x10800000-0x1087FFFF A 0x20000000 0x80000");
  JLINK_ExecCommand("map region 0x30000000-0x3007FFFF A 0x20000000 0x80000");

  // Make sure that areas filled with blank data are also programmed by J-Link SW
  JLINK_ExecCommand("SetDisableSkipBlankDataOnProg = 1");

  // Make sure that the J-Link SW does not perform a read-modify-write
  JLINK_ExecCommand("SetFlashDLNoRMWThreshold = 0");

  // Can't really use flash breakpoints as they would rewrite the entire code region
  JLINK_ExecCommand("DisableFlashBPs");

}


/***********************************************************************
*                    SEGGER Microcontroller GmbH                       *
*                        The Embedded Experts                          *
************************************************************************
*                                                                      *
*                  (c) SEGGER Microcontroller GmbH                     *
*                        All rights reserved                           *
*                          www.segger.com                              *
*                                                                      *
************************************************************************
*                                                                      *
************************************************************************
*                                                                      *
*                                                                      *
*  Licensing terms                                                     *
*                                                                      *
* The use in source and binary forms, with or without modification,    *
* is permitted for internal use only. The redistribution to any        *
* third party is prohibited.                                           *
*                                                                      *
*                                                                      *
* THIS SOFTWARE IS PROVIDED BY COPYRIGHT HOLDER "AS IS" AND ANY        *
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR   *
* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER BE        *
* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,     *
* OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,             *
* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR   *
* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  *
* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT         *
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE    *
* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH     *
* DAMAGE.                                                              *
*                                                                      *
************************************************************************

-------------------------- END-OF-HEADER -----------------------------

Purpose: Custom reset strategy maintained by Silicon Labs. Implements reset strategies 0 and 2. JTAG scan chains are not supported.
Literature:
  [1]  J-Link User Guide
  [2]  https://wiki.segger.com/J-Link_Reset_Strategies#Type_0:_Normal
*/

/*********************************************************************
*
*       Constants, fixed
*
**********************************************************************
*/
//
// Registers (ARM)
//
__constant U32 _AIRCR_ADDR                 = 0xE000ED0C; // Application Interrupt and Reset Control Register
__constant U32 _DHCSR_ADDR                 = 0xE000EDF0; // Debug Halting Control and Status Register
__constant U32 _DEMCR_ADDR                 = 0xE000EDFC; // Debug Exception and Monitor Control Register
__constant U32 _DSCSR_ADDR                 = 0xE000EE08; // RW Debug Security Control and Status Register

//
// Bits & Shifts (ARM)
//
__constant U32 _DP_CTRL_STAT_BIT_STICKYERR = (1 <<  5);
__constant U32 _DP_CTRL_STAT_BIT_DBGPWRUPACK = (1 << 29);
__constant U32 _DP_CTRL_STAT_BIT_SYSPWRUPACK = (1 << 31);
__constant U32 _DP_CTRL_STAT_BIT_DBGPWRUPREQ = (1 << 28);
__constant U32 _DP_CTRL_STAT_BIT_SYSPWRUPREQ = (1 << 30);

__constant U32 _DHCSR_DBGKEY               = (0xA05F << 16);
__constant U32 _DHCSR_C_DEBUGEN            = (1 <<  0);
__constant U32 _DHCSR_C_HALT               = (1 <<  1);
__constant U32 _DHCSR_S_HALT               = (1 << 17);
__constant U32 _DHCSR_S_RESET_ST           = (1 << 25);

__constant U32 _DEMCR_VC_CORERESET         = (1 <<  0);
__constant U32 _DEMCR_TRCENA               = (1 << 24);

__constant U32 _AIRCR_VECTKEY              = (0x05FA << 16);
__constant U32 _AIRCR_SYSRESETREQ          = (1 <<  2);


/*********************************************************************
*
*       Constants, configurable
*
**********************************************************************
*/

__constant U32 _DEF_BUSY_TIMEOUT = 250;

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

/*********************************************************************
*
*       _DAPClrStickyErr
*
*  Function description
*    Clears the DAP sticky error flags.
*/
static void _DAPClrStickyErr(void) {
  U32 v;
  //
  // The DP is slightly different for JTAG and SWD regarding clearing sticky error bits.
  //
  if (JLINK_ActiveTIF == JLINK_TIF_SWD) {
    JLINK_CORESIGHT_WriteDP(JLINK_CORESIGHT_DP_REG_ABORT, 0x1E);
  } else {
    v  = JLINK_CORESIGHT_ReadDP(JLINK_CORESIGHT_DP_REG_CTRL_STAT);
    v |= _DP_CTRL_STAT_BIT_STICKYERR;
    JLINK_CORESIGHT_WriteDP(JLINK_CORESIGHT_DP_REG_CTRL_STAT, v);
  }
}

/*********************************************************************
*
*       _IsHalted  
*
*       This function checks if the core is halted
*       Return values:
*         *  0: Not halted
*         *  1: Halted
*         * -1: Read error
*/
int _IsHalted(void)
{
  U32 v;
  // Get Debug Halting Control and Status register
  v = JLINK_MEM_ReadU32(_DHCSR_ADDR);
  if (v == 0xFFFFFFFF) {
    return -1;
  }

  JLINK_SYS_Report1("H DHCSR: ", v);
  // Read succeeded
  if (v & _DHCSR_S_HALT) {
    // Halt succeeded
    return 1;
  }
  return 0;
}

/*********************************************************************
*
*       _HaltCore  
*
*       This function attempts to halt the core
*       Return values:
*         *  0: Success
*         * -2: Halt failed
*/
int _HaltCore(void)
{
  U32 v;
  int Result;
  int start_time_ms, timeout_ms, current_time_ms;

  // Default return code to fail
  Result = -1;

  // Init one second timeout
  start_time_ms = JLINK_GetTime();
  timeout_ms = start_time_ms + 1000;

  // Halt core and poll until halted
  do {
    Result = _IsHalted();
    if (Result == 1) {
      // Halt succeeded
      current_time_ms = JLINK_GetTime();
      Result = 0;
      break;
    }
    else if (Result == 0) {
      // Enable debug and attempt halt
      JLINK_MEM_WriteU32(_DHCSR_ADDR, _DHCSR_DBGKEY | _DHCSR_C_DEBUGEN | _DHCSR_C_HALT);
    }
    current_time_ms = JLINK_GetTime();
  } while (current_time_ms < timeout_ms);

  JLINK_SYS_Report1("_HaltCore duration (ms): ", current_time_ms-start_time_ms);
  return Result;
}

/*********************************************************************
*
*       WaitForDP      
*
*       This function repeatedly tries to contact and setup the DP
*       Return values:
*         *  0: Success
*         * -2: Not supported CPU + interface combo
*         * -3: Readback of DP failed
*         * -4: DBGPWRUP and SYSPWRUP not acknowledged
*         * <0: Other error
*/
int _WaitForDP(void)
{
  U32 v;
  int Result;
  int start_time_ms, timeout_ms, current_time_ms;

  // Init one second timeout
  start_time_ms = JLINK_GetTime();
  timeout_ms = start_time_ms + 1000;
  Result = -1;
  do {

    if (JLINK_ActiveTIF == JLINK_TIF_SWD) {
      // >= 0 = OK, < 0 = Error, -2 = Not supported by the current CPU + interface combo
      Result = JLINK_CORESIGHT_Configure("");  // Perform JTAG->SWD switching
    }
    else {
      // Placeholder for now
      Result = JLINK_CORESIGHT_Configure("IRPre=0;DRPre=0;IRPost=0;DRPost=0;IRLenDevice=4");
    }
    JLINK_SYS_Report1("Configure result: ", Result);

    if ( Result == -2 ) {
      // CPU + interface combination not supported
      current_time_ms = JLINK_GetTime();
      break;
    }
    else if (Result >= 0) {

      JLINK_CORESIGHT_WriteDP(JLINK_CORESIGHT_DP_REG_ABORT, 0x1E); // Clear sticky error flags

      // Power up debug interface
      v = _DP_CTRL_STAT_BIT_DBGPWRUPREQ | _DP_CTRL_STAT_BIT_SYSPWRUPREQ;
      JLINK_CORESIGHT_WriteDP(JLINK_CORESIGHT_DP_REG_CTRL_STAT, v);

      // Read back acknowledgement bits
      v = JLINK_CORESIGHT_ReadDP(JLINK_CORESIGHT_DP_REG_CTRL_STAT);
      JLINK_SYS_Report1("DP CTRL/STAT: ", v);

      if ( v == 0xFFFFFFFF ) {
        // Readback failed
        Result = -3;
        continue;
      }
      else if ( v & (_DP_CTRL_STAT_BIT_DBGPWRUPACK | _DP_CTRL_STAT_BIT_SYSPWRUPACK) ) {
        // Powerup acknowledged
        current_time_ms = JLINK_GetTime();
        Result = 0;
        break;
      }
      else {
        Result = -4;
      }

    }
    current_time_ms = JLINK_GetTime();
  } while (current_time_ms < timeout_ms);
  JLINK_SYS_Report1("WaitForDP duration (ms): ", current_time_ms-start_time_ms);

  return Result;
}

/*********************************************************************
*
*       AttemptConnectSysresetHalt
*
*       This function tries to contact the debug interface, 
*       and halt the Cortex-M33.
*       Return values:
*         *  0: Success
*         * <0: Error
*/
int _AttemptConnect ( void )
{
  int Result;

  // Wait for debug interface to become available
  Result = _WaitForDP();
  if (Result < 0) {
    return Result;
  }

  // Wait for Secure Bootloader execution to complete
  Result = _HaltCore();
  if (Result < 0) {
    return Result;
  }

  return 0;
}

/*********************************************************************
*
*       AttemptConnectSysresetHalt
*
*       This function tries to contact the debug interface, 
*       issue a AIRCR.SYSRESETREQ and halt the 
*       Cortex-M33 at the reset vector.
*       Return values:
*         *  0: Success
*         * <0: Error
*/
int _AttemptSysresetHalt ( void )
{
  int t;
  U32 v;
  U32 DSCSRVal;
  U8  AllowFail;
  int Result;

  Result = 0;
  AllowFail = 0;
  DSCSRVal = JLINK_MEM_ReadU32(_DSCSR_ADDR);
  v  = DSCSRVal;
  v &= ~(1 << 17);
  v |=  (1 << 16);
  JLINK_MEM_WriteU32(_DSCSR_ADDR, v);

  //
  // Perform reset
  //
  JLINK_SYS_Report("Reset: Halt core after reset via DEMCR.VC_CORERESET.");
  JLINK_MEM_WriteU32(_DHCSR_ADDR, (_DHCSR_DBGKEY | _DHCSR_C_HALT | _DHCSR_C_DEBUGEN)); // Halt the CPU
  JLINK_MEM_WriteU32(_DEMCR_ADDR, (_DEMCR_VC_CORERESET | _DEMCR_TRCENA));              // Set vector catch on reset (to halt the CPU immediately after reset)
  _DAPClrStickyErr();                                                                  // Make sure that no sticky error bits are set on the DP
  JLINK_SYS_Report("Reset: Reset device via AIRCR.SYSRESETREQ.");
  JLINK_MEM_WriteU32(_AIRCR_ADDR, (_AIRCR_VECTKEY | _AIRCR_SYSRESETREQ));              // Issue reset request via SFR
  JLINK_SYS_Sleep(50);                                                                 // The spec. does not guarantee that the reset takes place immediately, so we give the target some time.
  //
  // Wait until S_RESET_ST is set
  //
  t = JLINK_GetTime() + _DEF_BUSY_TIMEOUT;          // Make sure that no sticky error bits are set on the DP
  JLINK_SYS_Report("Wait for S_RESET_ST == 1");
  do {
    v  = JLINK_MEM_ReadU32(_DHCSR_ADDR);
    v &= _DHCSR_S_RESET_ST;
    if (v) {
      break;
    }
    if ((t - JLINK_GetTime()) < 0) {
      if (AllowFail) {
        JLINK_SYS_Report("Reset: CPU has not been reset (DHCSR.S_RESET_ST never gets set). Probably because reset is not available in the current security state (SYSRESETREQS == 0). Details: https://urldefense.com/v3/__https://wiki.segger.com/J-Link_ARMv8-M*Non-secure_debug_access__;Iw!!N30Cs7Jr!WQAfZ35S7jgWKccL_sNDjCEim_a7R0VyhnP3D7N2REzzQ0_cmf-2W-BRhpiImxmLdRMBUWiHYShGosCc03Mes0nwNA$ ");
        Result = -1;
        goto Done;
      } else {
        JLINK_SYS_Report("Reset: CPU may have not been reset (DHCSR.S_RESET_ST never gets set).");
        Result = -1;             // Error, timeout
        goto Done;
      }
    }
  } while (1);
  //
  // Wait until S_RESET_ST is cleared
  //
  t = JLINK_GetTime() + _DEF_BUSY_TIMEOUT;
  JLINK_SYS_Report("Wait for S_RESET_ST == 0");
  do {
    v  = JLINK_MEM_ReadU32(_DHCSR_ADDR);
    v &= _DHCSR_S_RESET_ST;
    if (v == 0) {
      break;
    }
    if ((t - JLINK_GetTime()) < 0) {
      JLINK_SYS_Report("Reset: S_RESET_ST never gets cleared. CPU seems to be kept in reset forever.");
      return -1;
    }
  } while (1);


  // On A0 devices, after a number of device erase cycles, this has been observed to take >150 ms
  t = JLINK_GetTime() + 1000;
  JLINK_SYS_Report("Wait for vector catch");
  do {
    if (_IsHalted() == 1) {
      break;
    }
    if ((t - JLINK_GetTime()) < 0) {
      JLINK_SYS_Report("Device never halts after reset.");
      break;
    }
  } while (1);

  //
  // Make sure we clear the vector catch we have set before
  //
  JLINK_MEM_WriteU32(_DEMCR_ADDR, (0x0 | _DEMCR_TRCENA));

  if (_IsHalted() != 1) {
    JLINK_SYS_Report("Core did not halt after reset, halting it manually.");
    Result = _HaltCore();
  }
Done:
  return Result;
}

/*********************************************************************
*
*       Global functions
*
**********************************************************************
*/

/*********************************************************************
*
*       ResetTarget()
*
*  Function description
*    Replaces reset strategies of DLL. No matter what reset type is selected in the DLL, if this function is present, it will be called instead of the DLL internal reset.
*
*  Notes
*    (1) DLL expects target CPU to be halted / in debug mode, when leaving this function
*    (2) May use MEM_ API functions
*    (3) The caller ensures that the J-Link SW / FW caches are invalidated after this function
*/
int ResetTarget(void) {

  int Result;

  if (MAIN_ResetType == 2 || MAIN_ResetType == 101) {
    JLINK_SYS_Report("Detected MAIN_ResetType value of 2.  Using reset pin.");
    JLINK_TIF_ActivateTargetReset();      // Generate pin reset
    JLINK_SYS_Sleep(100);                 // Give reset some time
    JLINK_TIF_ReleaseTargetReset();
    JLINK_SYS_Sleep(20);                  // Delay after de-assert

    Result = _AttemptConnect();
    if ( Result < 0 ) {
      return Result;
    }
  }
  JLINK_SYS_Report1( "Using custom reset with MAIN_ResetType of ", MAIN_ResetType);

  // First reset attempt
  Result = _AttemptSysresetHalt();
  if ( Result == 0 ) {
    // Success!
    return 0;
  }

  // Did not succeed in connecting to target
  // Attempting a pin reset.
  JLINK_SYS_Report("First attempt failed. Using reset pin.");
  JLINK_TIF_ActivateTargetReset();
  JLINK_SYS_Sleep(100);
  JLINK_TIF_ReleaseTargetReset();

  // Connect after reset
  Result = _AttemptConnect();
  if ( Result < 0 ) {
    return Result;
  }
  // Retry reset
  Result = _AttemptSysresetHalt();
  if ( Result == 0 ) {
    // Success!
    return 0;
  }

  // Second attempt failed, halting core at least
  JLINK_SYS_Report("Second attempt failed. Halting wherever and returning.");
  Result = _HaltCore();
  if ( Result == 0 ) {
    // We managed to halt!
    return 0;
  }

  // Failure
  JLINK_SYS_Report( "Error: Unable to reset & halt target device!" );
  return -1;

}

/*************************** end of file ****************************/
