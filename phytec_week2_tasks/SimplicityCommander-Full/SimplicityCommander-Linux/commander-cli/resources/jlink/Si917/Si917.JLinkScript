/***********************************************************************
*                    SEGGER Microcontroller GmbH                       *
*                        The Embedded Experts                          *
************************************************************************
*                                                                      *
*                  (c) SEGGER Microcontroller GmbH                     *
*                        All rights reserved                           *
*                          www.segger.com                              *
*                                                                      *
************************************************************************
*                                                                      *
************************************************************************
*                                                                      *
*                                                                      *
*  Licensing terms                                                     *
*                                                                      *
* The use in source and binary forms, with or without modification,    *
* is permitted for internal use only. The redistribution to any        *
* third party is prohibited.                                           *
*                                                                      *
*                                                                      *
* THIS SOFTWARE IS PROVIDED BY COPYRIGHT HOLDER "AS IS" AND ANY        *
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    *
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR   *
* PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER BE        *
* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,     *
* OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,             *
* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR   *
* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY  *
* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT         *
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE    *
* USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH     *
* DAMAGE.                                                              *
*                                                                      *
************************************************************************

-------------------------- END-OF-HEADER -----------------------------

Purpose: Implementation of the generic Cortex-M device reset (Reset strategy Type 0: Normal).
Literature:
  [1]  J-Link User Guide
  [2]  https://wiki.segger.com/J-Link_Reset_Strategies#Type_0:_Normal
*/

/*********************************************************************
*
*       Constants, fixed
*
**********************************************************************
*/
//
// Registers (ARM)
//
__constant U32 _AIRCR_ADDR         = 0xE000ED0C; // Application Interrupt and Reset Control Register
__constant U32 _DHCSR_ADDR         = 0xE000EDF0; // Debug Halting Control and Status Register
__constant U32 _DEMCR_ADDR         = 0xE000EDFC; // Debug Exception and Monitor Control Register

//
// Bits & Shifts (ARM)
//
__constant U32 _DP_CTRL_STAT_BIT_STICKYERR        = (1 <<  5);
__constant U32 _DP_CTRL_STAT_BIT_DBGPWRUPACK      = (1 << 29);
__constant U32 _DP_CTRL_STAT_BIT_SYSPWRUPACK      = (1 << 31);
__constant U32 _DP_CTRL_STAT_BIT_DBGPWRUPREQ      = (1 << 28);
__constant U32 _DP_CTRL_STAT_BIT_SYSPWRUPREQ      = (1 << 30);

__constant U32 _DHCSR_DBGKEY                      = (0xA05F << 16);
__constant U32 _DHCSR_C_DEBUGEN                   = (1 <<  0);
__constant U32 _DHCSR_C_HALT                      = (1 <<  1);
__constant U32 _DHCSR_S_HALT                      = (1 << 17);
__constant U32 _DHCSR_S_RESET_ST                  = (1 << 25);

__constant U32 _DEMCR_VC_CORERESET                = (1 <<  0);
__constant U32 _DEMCR_TRCENA                      = (1 << 24);

__constant U32 _AIRCR_VECTKEY                     = (0x05FA << 16);
__constant U32 _AIRCR_SYSRESETREQ                 = (1 <<  2);


//
// SiWx91x Registers
//
//__constant U32 _QSPI_BASE_ADDR                  = 0x12000000;
//__constant U32 _QSPI_CTRL_ADDR                  = _QSPI_BASE_ADDR + 0x2C;
__constant U32 _QSPI_CLK_ADDR                     = 0x12040000;
__constant U32 _QSPI_CLK_VALUE                    = 0x00000101;
__constant U32 _QSPI_MODE_ADDR                    = 0x12040004;
__constant U32 _QSPI_MODE_MASK                    = 0x00010C00;
__constant U32 _ULP_CLKOSC_CTRL_REG               = 0x24048120;
__constant U32 _ULP_CLKOSC_RC_32KHZ_CLK_EN_BIT    = (1 << 16);
__constant U32 _MCUULP_VBAT_LFCLK_REG             = 0x24048020;
__constant U32 _MCUULP_CUULP_VBAT_LF_CLK_SEL_MASK = 7;
__constant U32 _MCUULP_CUULP_VBAT_LF_CLK_SEL_RC   = 2;
__constant U32 _MCUULP_CUULP_VBAT_LF_CLK_SWITCHED = (1 << 3);


/*********************************************************************
*
*       Constants, configurable
*
**********************************************************************
*/

__constant U32 _DEF_BUSY_TIMEOUT = 2000;


/*************************** end of file ****************************/

/*********************************************************************
*
*       Static code
*
**********************************************************************
*/

/*********************************************************************
*
*       _DAPClrStickyErr
*
*       Function description
*       Clears the DAP sticky error flags.
*/
static void _DAPClrStickyErr(void) {

  U32 v;

  //
  // The DP is slightly different for JTAG and SWD regarding clearing sticky error bits.
  //

  if (JLINK_ActiveTIF == JLINK_TIF_SWD) {

    JLINK_CORESIGHT_WriteDP(JLINK_CORESIGHT_DP_REG_ABORT, 0x1E);

  } else {

    v  = JLINK_CORESIGHT_ReadDP(JLINK_CORESIGHT_DP_REG_CTRL_STAT);
    v |= _DP_CTRL_STAT_BIT_STICKYERR;
    JLINK_CORESIGHT_WriteDP(JLINK_CORESIGHT_DP_REG_CTRL_STAT, v);

  }
}

/*********************************************************************
*
*         _SelectRCClock
*
*         This function attempts to select RC clock
*         Return values:
*           *  0: Success
*           * -1: Failed to select RC clock
*/
int _SelectRCClock(void)
{
  U32 v;
  int Result;
  int start_time_ms, timeout_ms, current_time_ms;

  // Default return code to fail
  Result = -1;

  // Check if the RC clock is already enabled
  v = JLINK_MEM_ReadU32(_ULP_CLKOSC_CTRL_REG);
  if ((v & _ULP_CLKOSC_RC_32KHZ_CLK_EN_BIT) != _ULP_CLKOSC_RC_32KHZ_CLK_EN_BIT) {

    // Enable RC clock
    JLINK_SYS_Report("Enabling RC clock.");
    JLINK_MEM_WriteU32(_ULP_CLKOSC_CTRL_REG, v | _ULP_CLKOSC_RC_32KHZ_CLK_EN_BIT);
    JLINK_SYS_Sleep(1);

  }

  // Init one second timeout
  start_time_ms = JLINK_GetTime();
  timeout_ms = start_time_ms + 1000;

  // Select the RC clock if it is not already selected
  v = JLINK_MEM_ReadU32(_MCUULP_VBAT_LFCLK_REG);
  if ((v & _MCUULP_CUULP_VBAT_LF_CLK_SEL_MASK) != _MCUULP_CUULP_VBAT_LF_CLK_SEL_RC) {

    JLINK_SYS_Report1("Selecting RC clock. Found ", v & _MCUULP_CUULP_VBAT_LF_CLK_SEL_MASK);
    JLINK_MEM_WriteU32(_MCUULP_VBAT_LFCLK_REG, (v & ~_MCUULP_CUULP_VBAT_LF_CLK_SEL_MASK) | _MCUULP_CUULP_VBAT_LF_CLK_SEL_RC);

    do {

        // Check if the RC clock is selected
        v = JLINK_MEM_ReadU32(_MCUULP_VBAT_LFCLK_REG);
        if (v & _MCUULP_CUULP_VBAT_LF_CLK_SWITCHED) {
          Result = 0;
          break;
        }
        current_time_ms = JLINK_GetTime();

    } while (current_time_ms < timeout_ms);

  }
  current_time_ms = JLINK_GetTime();
  JLINK_SYS_Report1("_SelectRCClock duration (ms): ", current_time_ms-start_time_ms);
  return Result;
}

/*********************************************************************
*
*       _HaltCore
*
*       This function attempts to halt the core
*       Return values:
*         *  0: Success
*         * -1: Halt failed
*/
int _HaltCore(void)
{
  U32 v;
  int Result;
  int start_time_ms, timeout_ms, current_time_ms;

  // Default return code to fail
  Result = -1;

  // Init one second timeout
  start_time_ms = JLINK_GetTime();
  timeout_ms = start_time_ms + 1000;

  // Halt core and poll until halted
  do {
    // Get Debug Halting Control and Status register
    v = JLINK_MEM_ReadU32(_DHCSR_ADDR);

    if (v != 0xFFFFFFFF) {
      JLINK_SYS_Report1("H DHCSR: ", v);
      // Read succeeded
      if (v & _DHCSR_S_HALT) {
        // Halt succeeded
        current_time_ms = JLINK_GetTime();
        Result = 0;
        break;
      }

      // Enable debug and attempt halt
      JLINK_MEM_WriteU32(_DHCSR_ADDR, _DHCSR_DBGKEY | _DHCSR_C_DEBUGEN | _DHCSR_C_HALT);
    }
    current_time_ms = JLINK_GetTime();
  } while (current_time_ms < timeout_ms);

  JLINK_SYS_Report1("_HaltCore duration (ms): ", current_time_ms-start_time_ms);
  return Result;
}

/*********************************************************************
*
*       WaitForDP
*
*       This function repeatedly tries to contact and setup the DP
*       Return values:
*         *  0: Success
*         * -2: Not supported CPU + interface combo
*         * -3: Readback of DP failed
*         * -4: DBGPWRUP and SYSPWRUP not acknowledged
*         * <0: Other error
*/
int _WaitForDP(void)
{
  U32 v;
  int Result;
  int start_time_ms, timeout_ms, current_time_ms;

  // Init one second timeout
  start_time_ms = JLINK_GetTime();
  timeout_ms = start_time_ms + 1000;
  Result = -1;
  do {

    if (JLINK_ActiveTIF == JLINK_TIF_SWD) {
      // >= 0 = OK, < 0 = Error, -2 = Not supported by the current CPU + interface combo
      Result = JLINK_CORESIGHT_Configure("");  // Perform JTAG->SWD switching
    }
    else {
      // Placeholder for now
      Result = JLINK_CORESIGHT_Configure("IRPre=0;DRPre=0;IRPost=0;DRPost=0;IRLenDevice=4");
    }
    JLINK_SYS_Report1("Configure result: ", Result);

    if ( Result == -2 ) {
      // CPU + interface combination not supported
      current_time_ms = JLINK_GetTime();
      break;
    }
    else if (Result >= 0) {

      JLINK_CORESIGHT_WriteDP(JLINK_CORESIGHT_DP_REG_ABORT, 0x1E); // Clear sticky error flags

      // Power up debug interface
      v = _DP_CTRL_STAT_BIT_DBGPWRUPREQ | _DP_CTRL_STAT_BIT_SYSPWRUPREQ;
      JLINK_CORESIGHT_WriteDP(JLINK_CORESIGHT_DP_REG_CTRL_STAT, v);

      // Read back acknowledgement bits
      v = JLINK_CORESIGHT_ReadDP(JLINK_CORESIGHT_DP_REG_CTRL_STAT);
      JLINK_SYS_Report1("DP CTRL/STAT: ", v);

      if ( v == 0xFFFFFFFF ) {
        // Readback failed
        Result = -3;
        continue;
      }
      else if ( v & (_DP_CTRL_STAT_BIT_DBGPWRUPACK | _DP_CTRL_STAT_BIT_SYSPWRUPACK) ) {
        // Powerup acknowledged
        current_time_ms = JLINK_GetTime();
        Result = 0;
        break;
      }
      else {
        Result = -4;
      }

    }
    current_time_ms = JLINK_GetTime();
  } while (current_time_ms < timeout_ms);
  JLINK_SYS_Report1("WaitForDP duration (ms): ", current_time_ms-start_time_ms);

  return Result;
}

/*********************************************************************
*
*       AttemptConnect
*
*       This function tries to contact the debug interface,
*       and halt the Cortex-M4.
*       Return values:
*         *  0: Success
*         * <0: Error
*/
int _AttemptConnect ( void )
{
  int Result;

  // Wait for debug interface to become available
  Result = _WaitForDP();
  if (Result < 0) {
    return Result;
  }

  // Wait for bootloader execution to complete
  Result = _HaltCore();
  if (Result < 0) {
    return Result;
  }

  return 0;
}

/*********************************************************************
*
*       AttemptConnectSysresetHalt
*
*       This function tries to contact the debug interface,
*       issue a AIRCR.SYSRESETREQ and halt the
*       Cortex-M4 at the reset vector.
*       Return values:
*         *  0: Success
*         * <0: Error
*/
int _AttemptSysresetHalt ( void )
{
  int t;
  int r;
  U32 v;
  U32 u;

  JLINK_CORESIGHT_WriteDP(JLINK_CORESIGHT_DP_REG_CTRL_STAT, 0xF0000000);

  JLINK_SYS_Report("Reset: Halt core after reset via DEMCR.VC_CORERESET.");
  JLINK_MEM_WriteU32(_DHCSR_ADDR, (_DHCSR_DBGKEY | _DHCSR_C_HALT | _DHCSR_C_DEBUGEN)); // Halt the CPU
  JLINK_MEM_WriteU32(_DEMCR_ADDR, (_DEMCR_VC_CORERESET | _DEMCR_TRCENA));              // Set vector catch on reset (to halt the CPU immediately after reset)
  _DAPClrStickyErr();                                                                  // Make sure that no sticky error bits are set on the DP
  JLINK_SYS_Report("Reset: Reset device via AIRCR.SYSRESETREQ. Extended timeout.");
  JLINK_MEM_WriteU32(_AIRCR_ADDR, (_AIRCR_VECTKEY | _AIRCR_SYSRESETREQ));              // Issue reset request via SFR
  JLINK_SYS_Sleep(50);                                                                 // The spec. does not guarantee that the reset takes place immediately, so we give the target some time.
  //
  // Wait until S_RESET_ST is set
  //
  t = JLINK_GetTime() + _DEF_BUSY_TIMEOUT;
  do {
    v  = JLINK_MEM_ReadU32(_DHCSR_ADDR);
    v &= _DHCSR_S_RESET_ST;
    if (v) {
      break;
    }
    if ((t - JLINK_GetTime()) < 0) {
      JLINK_SYS_Report("Reset: CPU may not have been reset (DHCSR.S_RESET_ST never gets set).");
      return -1;
    }
  } while (1);

  JLINK_MEM_WriteU32(_DHCSR_ADDR, (_DHCSR_DBGKEY | _DHCSR_C_HALT | _DHCSR_C_DEBUGEN)); // Halt the CPU
  JLINK_MEM_WriteU32(_DEMCR_ADDR, (_DEMCR_VC_CORERESET | _DEMCR_TRCENA));              // Set vector catch on reset (to halt the CPU immediately after reset)

  //
  // Wait until S_RESET_ST is cleared
  //
  t = JLINK_GetTime() + _DEF_BUSY_TIMEOUT;
  do {
    v  = JLINK_MEM_ReadU32(_DHCSR_ADDR);
    v &= _DHCSR_S_RESET_ST;
    if (v == 0) {
      break;
    }
    if ((t - JLINK_GetTime()) < 0) {
      JLINK_SYS_Report("Reset: S_RESET_ST never gets cleared. CPU seems to be kept in reset forever.");
      break;
    }
  } while (1);
  //
  // Make sure we clear the vector catch we have set before
  //
  JLINK_MEM_WriteU32(_DEMCR_ADDR, (0x0 | _DEMCR_TRCENA));

  //
  // Wait for the QSPI controller to be configured
  //
  JLINK_SYS_Report("Reset: Wait for the code areas to be accessible.");

  t = JLINK_GetTime() + _DEF_BUSY_TIMEOUT;
  do {

    JLINK_MEM_WriteU32(_DHCSR_ADDR, (_DHCSR_DBGKEY | _DHCSR_C_HALT | _DHCSR_C_DEBUGEN));  // Halt the CPU
    v = JLINK_MEM_ReadU32(_QSPI_CLK_ADDR);
    u = JLINK_MEM_ReadU32(_QSPI_MODE_ADDR);

    //JLINK_SYS_Report1("Reset: QSPI CLK: ", v);
    //JLINK_SYS_Report1("Reset: QSPI MODE: ", u);

    // Check for QSPI configuration
    if ((v == _QSPI_CLK_VALUE) && ((u & _QSPI_MODE_MASK) == _QSPI_MODE_MASK)) {
      JLINK_SYS_Report("Reset: QSPI configured.");
      break;
    }

    // Check for timeout
    if ((t - JLINK_GetTime()) < 0) {
      JLINK_SYS_Report("Reset: QSPI never gets configured according to the expected values.");
      return -1;
    }

    JLINK_MEM_WriteU32(_DHCSR_ADDR, (_DHCSR_DBGKEY | _DHCSR_C_DEBUGEN));                  // Release the core

  } while (1);


  return 0;
}

/*********************************************************************
*
*       Global functions
*
**********************************************************************
*/

/*********************************************************************
*
*       ResetTarget()
*
*  Function description
*    Replaces reset strategies of DLL. No matter what reset type is selected in the DLL, if this function is present, it will be called instead of the DLL internal reset.
*
*  Notes
*    (1) DLL expects target CPU to be halted / in debug mode, when leaving this function
*    (2) May use MEM_ API functions
*    (3) The caller ensures that the J-Link SW / FW caches are invalidated after this function
*/
int ResetTarget(void) {

  int Result;

  if (MAIN_ResetType == 2) {
    JLINK_SYS_Report("Detected MAIN_ResetType value of 2.  Using reset pin.");
    JLINK_TIF_ActivateTargetReset();      // Generate pin reset
    JLINK_SYS_Sleep(100);                 // Give reset some time
    JLINK_TIF_ReleaseTargetReset();
    JLINK_SYS_Sleep(20);                  // Delay after de-assert

    Result = _AttemptConnect();
    if ( Result < 0 ) {
      return Result;
    }
  }
  JLINK_SYS_Report1( "Using custom reset with MAIN_ResetType of ", MAIN_ResetType);

  // Check the clock configuration
  Result = _SelectRCClock();
  if ( Result < 0 ) {
    JLINK_SYS_Report("Failed to set the RC clock. Continuing anyway with reset.");
  }

  // First reset attempt
  Result = _AttemptSysresetHalt();
  if ( Result == 0 ) {
    // Success!
    return 0;
  }

  // Did not succeed in connecting to target
  // Attempting a pin reset.
  JLINK_SYS_Report("First attempt failed. Using reset pin.");
  JLINK_TIF_ActivateTargetReset();
  JLINK_SYS_Sleep(100);
  JLINK_TIF_ReleaseTargetReset();
  JLINK_SYS_Sleep(500); // Delay before attempting to connect

  // Connect after reset
  Result = _AttemptConnect();
  if ( Result < 0 ) {
    return Result;
  }

  // Second attempt failed, halting core at least
  JLINK_SYS_Report("Second attempt failed. Halting wherever and returning.");
  Result = _HaltCore();
  if ( Result == 0 ) {
    // We managed to halt!
    return 0;
  }

  // Failure
  JLINK_SYS_Report( "Error: Unable to reset & halt target device!" );
  return -1;

}

/*************************** end of file ****************************/
